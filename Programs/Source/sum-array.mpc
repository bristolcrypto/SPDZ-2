"""
  Compute the sum of clients input arrays.

  Demonstrate clients external to computing parties supplying input and receiving an authenticated result. See sum-client.cpp for client (and setup instructions).

  For an implementation with communications security see sum_commsec.mpc.
  
  Wait for MAX_NUM_CLIENTS to join the game or client finish flag to be sent
  before calculating the maximum.

  Note each client connects in a single thread and so is potentially blocked.
  
  Each round / game will reset and so this runs indefinitiely.
"""

from Compiler.types import sint, regint, Array, MemValue
from Compiler.instructions import listen, acceptclientconnection
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else


PORTNUM = 14000
MAX_NUM_CLIENTS = 8
ARRAY_UPPER_BOUND = 100

def accept_client_input():
    """
    Wait for socket connection, send share of random value, receive input and deduce share.
    Expect 3 inputs: unique id, value_to_add and flag to indicate end of this round.
    """
    client_socket_id = regint()
    acceptclientconnection(client_socket_id, PORTNUM)
    
    # Receive array length
    first_packet = sint.receive_from_client(2, client_socket_id)
    array_size = first_packet[1].reveal()
    total_size = array_size + 2
    
    # Receive array
    receive_client_array = Array(ARRAY_UPPER_BOUND, sint)
    client_inputs = Array(ARRAY_UPPER_BOUND, sint)
    @for_range(total_size)
    def _(i):
        receive_client_array = sint.receive_from_client(1, client_socket_id)    # Read 1 secure-int at a time
        client_inputs[i] = receive_client_array[0]                              # Recreate the array
        # print_ln('Just received %s', client_inputs[i].reveal())                 # Print received sints

    # store client_id and finish bit
    client_id = client_inputs[0]
    finish = client_inputs[total_size-1]
    # clear client_id and finish bit in order to be neutral to the sum
    client_inputs[0] = sint(0)
    client_inputs[total_size-1] = sint(0)
    return client_socket_id, client_id, client_inputs, finish

# Add the arrays
def compute_sum_of_clients_arrays(number_clients, client_values_matrix):
    """Compute sum of client_values_matrix"""
    sum_result = Array(ARRAY_UPPER_BOUND, sint)
    sum_result.assign_all(0)
    
    @for_range(number_clients)
    def for_each_client(i):
        @for_range(ARRAY_UPPER_BOUND)
        def for_each_value(j):
            sum_result[j] += client_values_matrix[i][j]

    return sum_result


def share_sum_to_clients(sockets, number_clients, clients_sum):
    """Send share of winning client id to all clients who joined game."""

    # Setup authenticate result using share of random.
    # client can validate S clients_sum * S rnd_from_triple = S auth_result
    rnd_from_triple = sint.get_random_triple()[0]
    auth_result = clients_sum * rnd_from_triple

    @for_range(number_clients)
    def loop_body(i):
        sint.write_shares_to_socket(sockets[i], [clients_sum, rnd_from_triple, auth_result])


def main():
    """Listen in while loop for players to join a game.
    Once maxiumum reached or have notified that round finished, run comparison and return result."""
    # Start listening for client socket connections
    listen(PORTNUM)
    print_ln('Listening for client connections on base port %s', PORTNUM)

    @do_while
    def game_loop():
        print_ln('\n\nStarting a new round of the game.')

        # Clients socket id (integer).
        client_sockets = Array(MAX_NUM_CLIENTS, regint)
        # Number of clients
        number_clients = MemValue(regint(0))
        # Clients secret input.
        client_values = Array(ARRAY_UPPER_BOUND, sint)
        client_values_matrix = Matrix(MAX_NUM_CLIENTS, ARRAY_UPPER_BOUND, sint)
        
        # Client ids to identity client
        client_ids = Array(MAX_NUM_CLIENTS, sint)

        # Loop round waiting for each client to connect
        @do_while
        def client_connections():
            
            client_sockets[number_clients], client_ids[number_clients], client_values, finish = accept_client_input()
            
            @for_range(ARRAY_UPPER_BOUND)
            def fill_matrix_loop(i):
                client_values_matrix[number_clients][i] = client_values[i]
            
            number_clients.write(number_clients+1)

            # continue while both expressions are false
            return (number_clients >= MAX_NUM_CLIENTS) + finish.reveal() == 0 

        sum_result = compute_sum_of_clients_arrays(number_clients, client_values_matrix)

        @for_range(ARRAY_UPPER_BOUND)
        def for_each_value(i):
            share_sum_to_clients(client_sockets, number_clients, sum_result[i])

        return True

main()
